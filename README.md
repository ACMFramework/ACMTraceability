# ACMTraceability

This is a machine learning based traceability solution implemented in Java. The aim of the project is to reduce manual effort spent
on creating trace links between software artefacts. Heterogeneous artefacts include Java source code, UML class diagrams, UML
sequence diagrams, UML use cases, JUnit tests, software architectures (conceptual and module view), and requirements specifications.
The approach is part of the ACM framework (github link, in the framework.Traceability package) and it can also be run independently
using the specified inputs.

##Brief summary of the approach

Trace link creation can be thought of as a binary classification problem: a classifier can be used to determine (with some accuracy)
if a given source and target artefact (for example a Java method and a JUnit test method) are related (positive instance) or are
unrelated (negative instance). Training data for the experiments has been obtained from open source systems: [MazeSolver]
(https://code.google.com/p/maze-solver/), [JGAP](http://jgap.sourceforge.net), [Neo4j](https://github.com/neo4j),
[Java Binary Parser](https://github.com/raydac/java-binary-block-parser), [Titan](https://github.com/thinkaurelius/titan), 
[MyRobotLab](https://github.com/MyRobotLab/myrobotlab). The selected classifier in the current implementation is the multilayer 
perceptron with backpropagation. (Change to other classifiers in TraceLinkCreator class's execute() method.)

##Features
Data instances are described by the following features:

1. **Source identifier**

2. **Target identifier**

1. **Name similarity** based on Levensthein distance - score is between 1.0 and 0.0 where 1.0 denotes a 100% match

2. **IsSourceContainer** value that can take the following values: 1 - it is a container element (that can contain other elements, such as a class can contain methods), 0 - it is a non-container element (such as a method or a field)

3. **IsTargetContainer** - same check for the target

4. **AbstractionLevelSeparation** - the distance between source and target in terms of their abstraction levels. Each abstraction level is given a value, e.g. high abstraction level is 0, medium is 1, low is 2. Requirements are high abstraction level, diagrams are medium, source code and unit tests are low abstraction level. Both source and target are assigned this number. The result is the absolute value of the difference between the source and the target.

5. **IsSourceRequirement** - if the source is a requirement type element, it is assigned the value 1, otherwise 0.

6. **IsSourceDiagram** - if the source is a UML diagram type element, it is assigned the value 1, otherwise 0.

7. **IsSourceArchitecture** - if the source is an architecture element, it is assigned the value 1, otherwise 0.

8. **IsSourceSourceCode** - if the source is a source code type element, it is assigned the value 1, otherwise 0.

9. **IsSourceUnitTest** - if the source is a unit test type element, it is assigned the value 1, otherwise 0.

10. The same features are applied for the targets

11. **RELATED** - where 0 denotes non-related (no trace link), 1 denotes related (a trace link exists between source and target)

Example: `SourceID, TargetID, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1`

This data instance denote the following case: Source is a Java class called "Maze" and target is a UML class called "Maze". 
The NameSimilarity feature shows that there is a 100% match between the names of the source and the target. Both source and target 
are container types, hence they are both given value 1 for the IsSourceContainer and IsTargetConatiner features. 
They are at different abstraction levels, and that is expressed by the value 1. 
The source is not a requirement, not a diagram, not an architecture, not a unit test but it is a source code type and hence 
IsSourceSourceCode is given the value 1. The target type is expressed in a similar manner and it is a diagram element, hence 
IsTargetDiagram is given the value 1. Since the two elements are related by a trace link, the related flag is set to 1.

##Training Data

Data (~1100 data instances) extracted from original artefacts is stored in .graphml files. Based on the contents of the .graphml files, feature data is 
generated and is stored in the TrainingData.csv file. The TrainingDataNominal.arff and TrainingDataNumeric.arff files were 
generated based on TrainingData.csv. The csv files can be found in the data folder.

**Related data instances:**
Relationships were manually set up between artefact elements based on human judgement.
Examples:
- A Java class is related to a UML class that has the same methods and name
- A jUnit test case is related to a Java method which is called in its assert statement

**Non-related data instances:**
Data instances containing pairs that are not related through a trace link were automatically generated by associating elements of 
a .graphml file with elements of another .graphml file. Human judgement was also required to make sure that artefact elements 
within the selected files are not actually linked.

## Example Usage
Let's assume that user would like to automate the linking of two artefacts: a Java class called Example.java, and a JUnit test 
class called Example_Test.java.

###Inputs:
1. Obtain the .graphml representation of these files: using the ACM framework's extraction and transformation functionality - framework
setup is described at: [ACM repository](https://github.com/ildiphd/ACMFramework). Following framework setup invoke functionality of JavaExtractor and Transformer classes by running the testExtractionAndTransformation()
test in the SetupTest class. Output: .graphml files representing Example.java (Example.graphml) and Example_Test.java 
(Example_Test.graphml))

2. Create XML input file.

		<Relations>
		  <Relation id="1_Inter">
		    <SourceNode>ut0C:\Users\I\Dropbox\TestCasesGraphml\Impl\Example.graphml
		    </SourceNode>
		    <TargetNode>sc0C:\Users\I\Dropbox\SourceCodeGraphml\Impl\Example_Test.graphml</TargetNode>
	   		</Relation>
	 	</Relations>
    
   SourceNode and TargetNode represent the two elements from Example.graphml and Example_Test.graphml (identified by unique ids)
   that we would like to check if they are connected by a trace link or not. The XML file can contain any number of such pairs obtained
   from any number of .graphml files.

###Running the model:
The functionality is invoked by the main method of the Traceability class. 

**Run in Eclipse:** set arguments (Run/Run Configurations/Arguments/Program Arguments[input xml file path]), run from main method.

**Run in the command line:** using javac and java commands specifying the argument [input xml file path]

Running the application creates an ACMTraceability folder in the user's home folder containing all necessary files (training data) and
the output.

###Output:
An XML output, which contains potentially connected source and targer elements idetified by unique ids. The file is placed in the user's home folder, in the ACMTraceability folder, and it is called: **finalOutput.xml**


